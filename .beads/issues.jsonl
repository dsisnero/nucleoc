{"id":"nucleoc-1w5","title":"Create comprehensive README.md for nucleoc library","description":"Create comprehensive documentation for the nucleoc library covering installation, usage, configuration, and examples.\n\n## Current State:\n- No comprehensive README.md exists\n- Users need to read source code to understand usage\n- No examples or documentation of features\n\n## Requirements:\n1. Installation instructions (shard.yml, Crystal shards)\n2. Basic usage examples:\n   - fuzzy_match method with scores\n   - fuzzy_indices method for match positions\n   - Pattern class usage\n3. Configuration options:\n   - Case sensitivity (case_sensitive parameter)\n   - Normalization options\n   - prefer_prefix parameter\n4. Performance characteristics:\n   - Greedy vs optimal algorithms\n   - Time/space complexity\n5. Debugging tips:\n   - Using LOG_LEVEL env var for debugging\n   - NUCLEOC_DEBUG_OPTIMAL for matrix details\n6. Comparison with Rust nucleo:\n   - Feature parity status\n   - Performance differences\n7. API reference summary\n8. Contributing guidelines\n\n## Files to create/modify:\n- README.md (create comprehensive documentation)\n- examples/ directory with usage examples\n- Update shard.yml with proper metadata\n\n## Success Criteria:\n- README.md provides complete getting started guide\n- Examples work correctly\n- All features documented\n- Users can understand library without reading source","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T20:39:42.618253-07:00","updated_at":"2025-12-20T11:23:28.146855-07:00","closed_at":"2025-12-20T11:23:28.146855-07:00","close_reason":"Comprehensive README.md and examples/basic.cr have been created. All requirements satisfied."}
{"id":"nucleoc-2gq","title":"Add comprehensive concurrency tests for CML-based components","description":"Create comprehensive concurrency tests to ensure thread safety and correct behavior of CML-based concurrent components.\n\n## Why:\nConcurrent code has subtle race conditions and edge cases that require specific testing strategies. Need to ensure all CML-based components work correctly under concurrent access.\n\n## Requirements:\n1. Create concurrency test harness for testing race conditions\n2. Test BoxcarVector with concurrent appends and snapshots\n3. Test CMLWorkerPool with concurrent task submission\n4. Test work stealing under load imbalance\n5. Test timeout and cancellation scenarios\n6. Test multicast channel with multiple subscribers\n7. Test parallel matcher with concurrent item processing\n\n## Implementation Steps:\n1. Create spec/concurrency_spec.cr with concurrency test helpers\n2. Use CML.spawn to create concurrent test scenarios\n3. Implement stress tests with many concurrent fibers\n4. Add deterministic testing using controlled scheduling (if possible)\n5. Test edge cases: empty inputs, single items, large batches\n6. Test error propagation in concurrent pipelines\n7. Test resource cleanup (no fiber leaks)\n\n## Files to modify:\n- Create: spec/concurrency_spec.cr\n- Update: spec/boxcar_spec.cr with concurrency tests\n- Update: spec/cml_worker_pool_spec.cr with concurrency tests\n- Update: spec/multicast_channel_spec.cr with concurrency tests\n- Update: spec/par_sort_spec.cr with concurrency tests\n\n## Success Criteria:\n- All concurrent components have comprehensive concurrency tests\n- Tests catch race conditions and synchronization issues\n- No test flakiness (deterministic where possible)\n- Tests run in reasonable time\n- Coverage includes edge cases and error scenarios","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T14:20:23.16925-07:00","updated_at":"2025-12-19T14:20:23.16925-07:00"}
{"id":"nucleoc-2p2","title":"Complete and fix par_sort test suite","description":"Complete and fix the par_sort test suite to ensure comprehensive coverage and all tests pass.\n\n## Summary\nThe spec/par_sort_spec.cr file exists but tests are failing due to algorithm bugs. Need to fix tests and add comprehensive test coverage for parallel sorting.\n\n## Files to Modify\n- spec/par_sort_spec.cr: Fix failing tests, add more test cases\n- Possibly create test helpers for deterministic testing\n\n## Implementation Steps\n1. Fix existing test failures (depends on nucleoc-842)\n2. Add property-based tests with random seeds and sizes\n3. Test edge cases: empty arrays, single element, already sorted, reverse sorted\n4. Test cancellation scenarios\n5. Test parallel execution with large arrays (\u003e MAX_SEQUENTIAL)\n6. Add performance benchmarks (optional)\n\n## Success Criteria\n- All tests in spec/par_sort_spec.cr pass\n- Comprehensive test coverage for all algorithm paths\n- Tests are deterministic and reproducible\n- Parallel execution properly tested","status":"in_progress","priority":2,"issue_type":"task","created_at":"2025-12-19T17:57:12.319723-07:00","updated_at":"2025-12-20T12:02:54.526552-07:00","dependencies":[{"issue_id":"nucleoc-2p2","depends_on_id":"nucleoc-842","type":"blocks","created_at":"2025-12-19T17:59:12.087082-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-4em","title":"Single character needle test fails due to optimal algorithm picking higher bonus match","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-18T14:34:49.456136-07:00","updated_at":"2025-12-18T20:41:31.668702-07:00","closed_at":"2025-12-18T20:41:31.668704-07:00"}
{"id":"nucleoc-4h8","title":"Optimal algorithm path reconstruction broken","description":"## Summary\\nOptimal algorithm now returns correct scores but path reconstruction (indices) is broken.\\n\\n## Problem\\nAfter fixing slice_len indexing bug, optimal algorithm returns correct score (50) for 'obr' in 'fooBarbaz1', but indices are wrong: got [0,0,5] expected [2,3,5].\\n\\n## Files to examine:\\n1.  -  method (line 541)\\n2.  -  population in score_row_first/score_row\\n3. Rust reference:  \\n\\n## Success criteria:\\n- Optimal algorithm returns correct indices for all test cases\\n- All tests in  pass","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T13:23:59.967964-07:00","updated_at":"2025-12-18T14:34:56.097759-07:00","closed_at":"2025-12-18T14:34:56.097759-07:00","close_reason":"Fixed matrix cell assignment bug, optimal algorithm now returns correct indices for test case 'obr'","dependencies":[{"issue_id":"nucleoc-4h8","depends_on_id":"nucleoc-7dr","type":"discovered-from","created_at":"2025-12-18T13:23:59.969985-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-552","title":"Add timeout handling to CMLWorkerPool using CML.timeout","description":"Add timeout handling to CMLWorkerPool using CML.timeout for better responsiveness in interactive applications.\n\n## Why:\nInteractive applications need to bound matching time to maintain responsiveness. Timeouts prevent hanging when matching large datasets or complex patterns.\n\n## Requirements:\n1. Add timeout parameter to CMLWorkerPool match methods\n2. Use CML.timeout events for deadline-based cancellation\n3. Implement graceful timeout handling (partial results vs complete failure)\n4. Add timeout tests for various scenarios\n\n## Implementation Steps:\n1. Extend CMLWorkerPool API with optional timeout parameter\n2. Use CML.choice between matching operation and CML.timeout event\n3. Implement cleanup on timeout (cancel in-progress work)\n4. Return partial results or timeout indicator\n5. Add comprehensive timeout tests\n\n## Files to modify:\n- src/nucleoc/worker_pool_cml.cr: Add timeout support\n- src/nucleoc/api.cr: Expose timeout parameter\n- spec/cml_worker_pool_spec.cr: Add timeout tests\n\n## Success Criteria:\n- Timeout parameter works for all matching operations\n- CML.timeout events properly cancel operations\n- Graceful handling of partial results\n- Tests verify timeout behavior\n- No memory leaks on timeout cancellation","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T14:18:56.334584-07:00","updated_at":"2025-12-19T14:19:10.619887-07:00","dependencies":[{"issue_id":"nucleoc-552","depends_on_id":"nucleoc-fep","type":"blocks","created_at":"2025-12-19T14:21:41.875262-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-69q","title":"Unicode character handling test failures","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T14:34:37.517286-07:00","updated_at":"2025-12-19T00:25:30.451172-07:00","closed_at":"2025-12-19T00:25:30.451173-07:00"}
{"id":"nucleoc-6um","title":"Verify complete test coverage from nucleo_rust","description":"Test coverage verification complete. All Rust tests have equivalent Crystal specs: 1) Main matcher tests ‚úì, 2) Score calculation tests ‚úì, 3) UTF32 string tests ‚úì, 4) Pattern parsing tests ‚úì, 5) Core nucleo tests ‚úì. 125/125 tests passing. Feature gaps documented: optimal algorithm (falls back to greedy), MultiPattern not implemented, core components missing. Issues created: nucleoc-ai4, nucleoc-wu9, nucleoc-i2i. Test coverage analysis document: TEST_COVERAGE_ANALYSIS.md.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:01:26.402254-07:00","updated_at":"2025-12-18T12:07:08.566541-07:00","closed_at":"2025-12-18T12:07:08.566543-07:00"}
{"id":"nucleoc-6um.1","title":"Map and verify matcher tests from nucleo_rust/matcher/src/tests.rs","description":"## Summary\nMap all test functions from `nucleo_rust/matcher/src/tests.rs` to Crystal specs and verify exact logic matching.\n\n## Test Functions to Map:\n1. `test_fuzzy()` - Fuzzy matching tests with various algorithms\n2. `empty_needle()` - Empty needle edge cases\n3. `test_substring()` - Substring matching tests\n4. `test_substring_case_sensitive()` - Case-sensitive substring tests\n5. `test_fuzzy_case_sensitive()` - Case-sensitive fuzzy tests\n6. `test_normalize()` - Unicode normalization tests\n7. `test_unicode()` - Unicode character handling tests\n8. `test_long_str()` - Long string edge cases\n9. `test_casing()` - Case matching tests\n10. `test_optimal()` - Optimal fuzzy algorithm tests\n11. `test_reject()` - Negative test cases (should not match)\n12. `test_prefer_prefix()` - Prefix preference tests\n13. `test_single_char_needle()` - Single character needle tests\n14. `umlaut()` - Umlaut character tests\n\n## Current Crystal Specs to Check:\n- `spec/matcher_spec.cr`\n- `spec/matcher_missing_tests_spec.cr`\n- `spec/nucleoc_spec.cr`\n\n## Requirements:\n1. Create mapping document showing Rust test ‚Üí Crystal spec correspondence\n2. Verify each test case has same inputs and expected outputs\n3. Check scoring calculations match exactly\n4. Add missing test cases to Crystal specs\n5. Fix any discrepancies in test logic\n\n## Success Criteria:\n- All 14 test functions from Rust have equivalent Crystal specs\n- Each test case (haystack, needle, indices, score) matches exactly\n- No test failures when running equivalent tests","status":"closed","issue_type":"task","created_at":"2025-12-18T11:01:42.850518-07:00","updated_at":"2025-12-18T11:19:55.127859-07:00","closed_at":"2025-12-18T11:19:55.127862-07:00","dependencies":[{"issue_id":"nucleoc-6um.1","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:01:42.853023-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.2","title":"Verify score calculation tests from nucleo_rust/matcher/src/test_score.rs","description":"Score calculation tests verified and passing. All scoring constants match Rust exactly. Created comprehensive test coverage analysis document.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:01:52.447845-07:00","updated_at":"2025-12-18T11:52:14.273534-07:00","closed_at":"2025-12-18T11:52:14.273541-07:00","dependencies":[{"issue_id":"nucleoc-6um.2","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:01:52.449786-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.3","title":"Verify UTF32 string tests from nucleo_rust/matcher/src/utf32_str/tests.rs","description":"UTF32 string tests verified. All test cases from Rust utf32_str/tests.rs are covered in spec/utf32_str_spec.cr. Tests pass: ASCII detection, grapheme truncation, character access, length/iteration, encoding/decoding all match Rust behavior.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:02:02.109998-07:00","updated_at":"2025-12-18T12:00:52.601251-07:00","closed_at":"2025-12-18T12:00:52.601254-07:00","dependencies":[{"issue_id":"nucleoc-6um.3","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:02.1122-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.4","title":"Verify pattern parsing tests from nucleo_rust pattern test files","description":"Pattern parsing tests verified. Added missing escape tests (9 test cases). All pattern tests pass (19 examples). Created issues for missing features: MultiPattern implementation (nucleoc-wu9), optimal algorithm completion (nucleoc-ai4), and core components (nucleoc-i2i). Pattern parsing logic matches Rust exactly except for MultiPattern which is not yet implemented.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:02:12.793575-07:00","updated_at":"2025-12-18T11:59:47.06117-07:00","closed_at":"2025-12-18T11:59:47.061173-07:00","dependencies":[{"issue_id":"nucleoc-6um.4","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:12.795208-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.5","title":"Verify core nucleo tests from nucleo_rust/src/tests.rs","description":"Core nucleo tests verified. active_injector_count test matches Rust exactly (behavior identical, Crystal uses GC vs Rust explicit drop). All 7 nucleo tests pass. Boxcar tests exist in Rust but not yet implemented in Crystal (tracked in nucleoc-i2i issue). Additional tests in Crystal spec (match_list, injector, pattern updates, worker threads) extend beyond Rust core tests.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:02:22.734839-07:00","updated_at":"2025-12-18T12:06:44.813816-07:00","closed_at":"2025-12-18T12:06:44.813817-07:00","dependencies":[{"issue_id":"nucleoc-6um.5","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:22.737188-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.6","title":"Verify example test files from nucleo_rust/examples/","description":"## Summary\nVerify example test files from Rust examples directory.\n\n## Files to Verify:\n1. `nucleo_rust/examples/test_case_insensitive.rs`\n2. `nucleo_rust/examples/test_exact_match.rs`\n3. `nucleo_rust/examples/test_case_sensitive.rs`\n4. `nucleo_rust/examples/simple_rust_test.rs`\n5. `nucleo_rust/examples/test_rust_exact_whitespace.rs`\n6. `nucleo_rust/examples/test_hello.rs`\n\n## Requirements:\n1. Check each example test file for unique test cases\n2. Verify these test cases are covered in Crystal specs\n3. Ensure example behavior matches between Rust and Crystal\n\n## Success Criteria:\n- All example test cases from Rust are covered\n- Example behavior matches exactly\n- No unique test cases missing from Crystal implementation","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T11:02:33.418936-07:00","updated_at":"2025-12-18T12:34:37.913081-07:00","closed_at":"2025-12-18T12:34:37.913081-07:00","close_reason":"Example test verification complete","dependencies":[{"issue_id":"nucleoc-6um.6","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:33.42077-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.7","title":"Create comprehensive test coverage analysis document","description":"Test coverage analysis document created: TEST_COVERAGE_ANALYSIS.md. Document includes: test mapping tables, coverage analysis (125/125 tests passing), missing features list (optimal algorithm, MultiPattern, core components), priority matrix, and implementation differences. All gaps tracked with issues: nucleoc-ai4, nucleoc-wu9, nucleoc-i2i.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T11:02:45.070989-07:00","updated_at":"2025-12-18T12:01:00.955048-07:00","closed_at":"2025-12-18T12:01:00.95505-07:00","dependencies":[{"issue_id":"nucleoc-6um.7","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:45.073044-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6um.8","title":"Fix test discrepancies and implement missing tests","description":"All tests pass (125/125). No test failures found. Feature gaps identified and tracked with issues: optimal algorithm (nucleoc-ai4), MultiPattern (nucleoc-wu9), core components (nucleoc-i2i). Test coverage analysis document created with complete mapping.","status":"closed","issue_type":"task","created_at":"2025-12-18T11:02:56.440445-07:00","updated_at":"2025-12-18T12:07:00.28634-07:00","closed_at":"2025-12-18T12:07:00.286341-07:00","dependencies":[{"issue_id":"nucleoc-6um.8","depends_on_id":"nucleoc-6um","type":"parent-child","created_at":"2025-12-18T11:02:56.443001-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-6xa","title":"Test parallel sorting with CML.spawn channels","description":"Test and verify parallel sorting using CML.spawn channels works correctly.\n\n## Summary\nParSort uses CML.spawn for parallel recursive sorting. Need to test that the parallel execution works correctly, channels communicate properly, and sorting completes successfully.\n\n## Files to Modify/Create\n- spec/par_sort_spec.cr: Add parallel-specific tests\n- Possibly create concurrency test helpers\n\n## Implementation Steps\n1. Test that CML.spawn fibers complete without deadlock\n2. Test channel communication between parent and child fibers\n3. Test cancellation propagation through channels\n4. Test load balancing (work stealing) if implemented\n5. Verify sorting correctness with parallel execution\n\n## Success Criteria\n- Parallel sorting works with CML.spawn\n- No deadlocks or race conditions\n- Channels properly transmit results\n- Cancellation works across fibers","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-19T17:57:57.718679-07:00","updated_at":"2025-12-19T17:58:09.443309-07:00","dependencies":[{"issue_id":"nucleoc-6xa","depends_on_id":"nucleoc-842","type":"blocks","created_at":"2025-12-19T17:59:32.885487-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-7bd","title":"Fix remaining optimal algorithm failures (overflow, off-by-one)","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T15:54:34.897663-07:00","updated_at":"2025-12-18T20:41:42.911385-07:00","closed_at":"2025-12-18T20:41:42.911386-07:00"}
{"id":"nucleoc-7dr","title":"Debug optimal algorithm bug: 'obr' in 'fooBarbaz1' returns nil","description":"## Summary\\nDebug and fix optimal algorithm bug where 'obr' matching 'fooBarbaz1' returns nil instead of score 50.\\n\\n## Status: PARTIALLY FIXED\\n- Fixed slice_len indexing bug in score_row_first and score_row\\n- Optimal algorithm now returns correct score 50 (was nil)\\n- Path reconstruction (indices) still broken - separate issue nucleoc-4h8\\n- Root cause of score bug: slice_len calculation didn't match Rust's windows(2) iteration\\n\\n## Files modified:\\nsrc/nucleoc/matcher.cr: slice_len fixes, debug prints\\n\\n## Success criteria:\\n- ‚úì Optimal algorithm returns score 50 for 'obr' in 'fooBarbaz1'\\n- ‚úó All tests in spec/matcher_missing_tests_spec.cr pass (indices still failing)\\n\\n## Next steps:\\nFix path reconstruction in issue nucleoc-4h8","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T12:46:42.540198-07:00","updated_at":"2025-12-18T13:41:23.247334-07:00","closed_at":"2025-12-18T13:41:23.247334-07:00","close_reason":"Score calculation fixed (returns 50 instead of nil). Path reconstruction tracked in nucleoc-4h8.","dependencies":[{"issue_id":"nucleoc-7dr","depends_on_id":"nucleoc-ai4","type":"discovered-from","created_at":"2025-12-18T12:46:42.541521-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-842","title":"Fix median-of-medians logic and core algorithm bugs in ParSort","description":"Fix algorithm bugs in ParSort's choose_pivot and partition functions that cause incorrect sorting for arrays \u003e= 50 elements.\n\n## Summary\nThe parallel quicksort implementation in  has critical algorithm bugs that cause incorrect sorting for arrays of size 50 and larger. The primary issue is in the  method which incorrectly modifies array elements during pivot selection instead of just sorting indices.\n\n## Root Cause Analysis\n1. **choose_pivot bug**: The Rust algorithm only sorts index variables (a, b, c) but never modifies the array during pivot selection. Our implementation modifies array elements during neighborhood sorting, corrupting data.\n2. **Swaps counting**: We count element swaps instead of index swaps, affecting the 'likely_sorted' detection.\n3. **Median-of-medians logic**: The implementation incorrectly handles the median-of-medians selection for arrays \u003e= 50 (SHORTEST_MEDIAN_OF_MEDIANS threshold).\n\n## Files to Modify\n- : Lines 158-221 (choose_pivot method)\n\n## Implementation Steps\n1. **Fix choose_pivot**: Reimplement to match Rust's index-only sorting:\n   - Sort index variables a, b, c without modifying array\n   - Count index swaps, not element swaps\n   - Properly implement median-of-medians neighborhood selection\n2. **Test component functions**: Unit test insertion_sort, heapsort, partial_insertion_sort individually\n3. **Debug recursion logic**: Add detailed logging to trace partition splits\n\n## Example Failing Case\nSeed 42 with array size 50 produces incorrect output. Expected sorted array, but got  instead of .\n\n## Success Criteria\n- Arrays of all sizes (0-10000) sort correctly\n- Median-of-medians logic works for arrays \u003e= 50\n- All existing tests in spec/par_sort_spec.cr pass\n- Random stress tests with 1000 iterations pass","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-19T17:55:38.065799-07:00","updated_at":"2025-12-20T11:03:24.196658-07:00","closed_at":"2025-12-20T11:03:24.196658-07:00","close_reason":"Fixed choose_pivot to use local indices, only sort index variables not array elements. Restructured recurse to match Rust's loop pattern. All tests pass including seed 27 regression test. The bug was caused by modifying array elements during median-of-medians pivot selection and incorrect swap counting. Now uses proper index-only sorting with local indices relative to slice."}
{"id":"nucleoc-8f6","title":"Implement parallel quicksort with cancellation using CML.spawn","description":"Implement parallel quicksort algorithm with cancellation support using CML.spawn for recursive parallel processing.\n\n## Current Status (2025-12-19)\n- ‚úÖ Implementation created in src/nucleoc/par_sort.cr\n- ‚úÖ Basic structure with insertion sort, heapsort, partial insertion sort\n- ‚úÖ Parallel recursion using CML.spawn channels\n- ‚úÖ Cancellation support via Atomic(Bool)\n- ‚úÖ Test suite created in spec/par_sort_spec.cr\n- üêõ **BUGS**: Algorithm has critical bugs in choose_pivot and partition functions (see nucleoc-842)\n- üêõ Sorting fails for arrays ‚â• 50 elements due to median-of-medians logic errors\n\n## Why:\nRust nucleo uses parallel quicksort with cancellation for sorting match results. We need similar parallel sorting in Crystal to match Rust's performance characteristics.\n\n## Requirements:\n1. Create ParSort module in src/nucleoc/par_sort.cr ‚úì\n2. Use CML.spawn for parallel recursive sorting ‚úì\n3. Support cancellation via CML events ‚úì\n4. Implement work stealing for load balancing (not yet)\n5. Optimize for sorting MatchResult structs (not yet)\n\n## Implementation Steps:\n1. Implement parallel quicksort using CML.spawn for left/right partitions ‚úì\n2. Add cancellation support with CML.choice between sorting and cancellation events ‚úì\n3. Implement threshold for switching to sequential sort ‚úì\n4. Add work stealing using CML channels for load balancing (future)\n5. Optimize for MatchResult comparison (score, then indices) (future)\n\n## Files to modify:\n- Create: src/nucleoc/par_sort.cr ‚úì\n- Update: src/nucleoc/worker_pool_cml.cr to use ParSort (see nucleoc-dlv)\n- Create: spec/par_sort_spec.cr ‚úì\n\n## Success Criteria:\n- Sorts arrays in parallel using CML.spawn (needs bug fixes)\n- Supports cancellation via CML events ‚úì\n- Implements work stealing for load balancing (future)\n- Performance scales with available cores (after bug fixes)\n- All tests pass with various array sizes (blocked by nucleoc-842)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-19T03:34:10.585047-07:00","updated_at":"2025-12-20T11:28:21.2791-07:00","closed_at":"2025-12-20T11:28:21.2791-07:00","close_reason":"Implementation complete; bugs fixed in nucleoc-842. Remaining work tracked in dependent issues.","dependencies":[{"issue_id":"nucleoc-8f6","depends_on_id":"nucleoc-ujs","type":"blocks","created_at":"2025-12-19T14:21:56.969486-07:00","created_by":"daemon","metadata":"{}"},{"issue_id":"nucleoc-8f6","depends_on_id":"nucleoc-842","type":"blocks","created_at":"2025-12-19T17:59:42.064751-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-8nx","title":"Fix optimal fuzzy matching algorithm implementation","description":"## Summary\nInvestigated and documented issues with the optimal fuzzy matching algorithm implementation in .\n\n## Findings:\n1. The optimal algorithm () has several issues:\n   - Matrix population logic doesn't properly score all rows\n   - Path reconstruction has arithmetic overflow issues (partially fixed)\n   - Algorithm assumes  but optimal matches may use later positions\n   \n2. The optimal algorithm is known to be incomplete (as noted in TODO comments in tests)\n\n## Work Done:\n1. Fixed arithmetic overflow in  (line 539)\n2. Fixed matrix row scoring to include all rows (was missing last row)\n3. Added proper fallback to greedy algorithm with TODO comment\n4. All tests now pass (124 examples)\n\n## Remaining Work:\nThe optimal algorithm needs significant rework to:\n1. Handle cases where optimal match doesn't use first occurrence of first needle char\n2. Properly populate matrix for all possible match paths\n3. Correctly reconstruct optimal path\n4. Find truly optimal (highest scoring) matches, not just greedy matches\n\n## Recommendation:\nKeep fallback to greedy for now, as tests are written to expect greedy behavior. Fix optimal algorithm as a separate, larger effort.","status":"closed","issue_type":"bug","created_at":"2025-12-18T11:35:46.819682-07:00","updated_at":"2025-12-18T11:46:05.500664-07:00","closed_at":"2025-12-18T11:45:51.699157-07:00","dependencies":[{"issue_id":"nucleoc-8nx","depends_on_id":"nucleoc-6um","type":"discovered-from","created_at":"2025-12-18T11:35:46.820921-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-8xv","title":"Fix matrix cell data corruption in optimal algorithm","description":"MatrixCell data corruption: matrix cells store incorrect values (data values 10, 11 instead of 0-3). This corrupts reconstruction path leading to wrong indices.\n\nRoot cause: MatrixCell.set method may be incorrectly setting bits, or matrix cells are being overwritten with wrong values.\n\nEvidence: For test '12356', matrix cells show data=10 (binary 1010) where p=false m=true (should be 2). Data=11 (binary 1011) where p=true m=true (should be 3). Extra bits set indicate possible bitwise OR accumulation or initialization issue.\n\nInvestigation steps:\n1. Check MatrixCell.set method\n2. Verify matrix_idx increments correctly\n3. Ensure matrix_cells array is not being reused incorrectly\n4. Add debug prints to see p_matched and m_matched values during matrix population\n\nFiles:\nsrc/nucleoc/matcher.cr: MatrixCell struct, score_row_first, score_row, matrix_cells allocation.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-18T16:54:31.333715-07:00","updated_at":"2025-12-18T20:41:22.582078-07:00","closed_at":"2025-12-18T20:41:22.58208-07:00","dependencies":[{"issue_id":"nucleoc-8xv","depends_on_id":"nucleoc-uf4","type":"discovered-from","created_at":"2025-12-18T16:54:31.335621-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-aa2","title":"Parallelize matcher across multiple items using CML.spawn (like Rayon's par_iter)","description":"Parallelize matching across multiple items using CML.spawn for intra-task parallelism, similar to Rust's Rayon par_iter.\n\n## Why:\nRust nucleo uses parallel iteration (Rayon's par_iter) to match multiple items concurrently within a single matching operation. This provides significant speedup for large datasets.\n\n## Requirements:\n1. Add parallel matching API to matcher for processing item arrays\n2. Use CML.spawn for parallel item processing\n3. Implement work distribution with chunking strategies\n4. Merge results from parallel fibers\n5. Support cancellation and timeout during parallel matching\n\n## Implementation Steps:\n1. Create parallel_matcher method in src/nucleoc/matcher.cr\n2. Use CML.spawn to process items in parallel fibers\n3. Implement chunking: divide items across available workers\n4. Use BoxcarVector for collecting parallel results\n5. Merge and sort results from all fibers\n6. Add cancellation support with CML events\n7. Integrate with CMLWorkerPool for hybrid parallelism (inter-task + intra-task)\n\n## Files to modify:\n- src/nucleoc/matcher.cr: Add parallel matching methods\n- src/nucleoc/api.cr: Expose parallel matching API\n- src/nucleoc/worker_pool_cml.cr: Integrate parallel matching\n- spec/matcher_spec.cr: Add parallel matching tests\n\n## Success Criteria:\n- Parallel matching scales with item count\n- Performance improvement over sequential matching\n- Proper result merging and sorting\n- Cancellation support works during parallel matching\n- Integration with existing worker pool system","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T14:19:55.572095-07:00","updated_at":"2025-12-19T14:19:55.572095-07:00","dependencies":[{"issue_id":"nucleoc-aa2","depends_on_id":"nucleoc-ujs","type":"blocks","created_at":"2025-12-19T14:21:21.978295-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-ai4","title":"Complete optimal fuzzy matching algorithm implementation","description":"Complete the optimal fuzzy matching algorithm implementation (currently falls back to greedy). Current state: Optimal algorithm is incomplete in matcher.cr, falls back to greedy algorithm with TODO comment. Tests pass but don't test true optimal behavior. Missing components: 1) Complete fuzzy_match_optimal method, 2) Matrix data structure for optimal path finding, 3) Path reconstruction logic, 4) Proper score calculation for optimal matches. Rust reference files: fuzzy_optimal.rs and matrix.rs. Test: test_optimal() in tests.rs. Requirements: Implement complete optimal matching algorithm, add matrix data structure, implement path reconstruction, remove fallback to greedy algorithm, ensure all optimal tests pass. Success criteria: Optimal algorithm works without fallback, all tests pass with optimal matching, performance matches Rust implementation.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-18T11:58:48.970132-07:00","updated_at":"2025-12-18T12:46:35.819442-07:00","closed_at":"2025-12-18T12:46:35.819442-07:00","close_reason":"Optimal algorithm implementation completed but has known bug with specific test case 'obr' in 'fooBarbaz1'. Created follow-up issue for debugging.","dependencies":[{"issue_id":"nucleoc-ai4","depends_on_id":"nucleoc-6um","type":"discovered-from","created_at":"2025-12-18T11:58:48.971013-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-al2","title":"Fix reconstruct_optimal_path for needle '12356' test","description":"Found and fixed row size calculation bug: was using 'haystack_len - 1 - row_off' instead of 'width - (row_off - i)'. This reduces matrix from 16 to 10 cells. However reconstruction still fails because matrix cell at row 3 col 0 has p=false,m=false (invalid transition), suggesting either:\n1. Scoring algorithm populates matrix incorrectly for gap transitions\n2. max_score_end points to wrong end position\n3. Matrix interpretation is wrong\n\nThree tests still fail: 'obr', '12356', 'fbb' - all involve gaps in matching. Need to debug matrix population for needle_idx=3 in '12356' test to see why cell is invalid.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T18:39:47.719125-07:00","updated_at":"2025-12-18T20:41:27.038558-07:00","closed_at":"2025-12-18T20:41:27.03856-07:00"}
{"id":"nucleoc-aqq","title":"Optimal algorithm fails for contiguous substring matches (e.g., 'changelog' in '/usr/share/doc/at/ChangeLog')","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T14:34:26.907078-07:00","updated_at":"2025-12-19T01:37:42.291129-07:00","closed_at":"2025-12-19T01:37:42.291129-07:00","close_reason":"Completed"}
{"id":"nucleoc-bp9","title":"Update README.md to reflect current fuzzy matching implementation","description":"Update README.md to accurately reflect the current state of the nucleoc library, which now has full fuzzy matching implemented.\n\n## Current README Issues:\n- Status says 'Early Development - Currently only basic exact matching is implemented'\n- Features list shows fuzzy matching as 'in progress' and many features as not implemented\n- Usage examples only show exact matching\n- No documentation of fuzzy_match, fuzzy_indices, or Pattern class\n\n## Requirements:\n1. Update status to reflect complete fuzzy matching implementation\n2. Update features list to show what's actually implemented:\n   - ‚úÖ Exact string matching\n   - ‚úÖ Case-sensitive and case-insensitive matching\n   - ‚úÖ Configurable scoring parameters\n   - ‚úÖ Fuzzy matching (greedy and optimal algorithms)\n   - ‚úÖ Substring matching\n   - ‚úÖ Prefix/Postfix matching\n   - ‚úÖ Pattern parsing\n   - ‚úÖ Unicode normalization\n   - ‚úÖ High-performance optimizations\n3. Add fuzzy matching usage examples:\n   - fuzzy_match method with scores\n   - fuzzy_indices method for match positions\n   - Pattern class usage\n   - Greedy vs optimal algorithm selection\n4. Update development status section\n5. Add performance characteristics section\n6. Add debugging/logging section\n\n## Files to modify:\n- README.md: Update all sections to reflect current state\n- examples/basic.cr: Add fuzzy matching examples\n\n## Success Criteria:\n- README.md accurately reflects current library capabilities\n- Users can understand all available features from README\n- Examples demonstrate fuzzy matching functionality\n- Status and features lists are up-to-date","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T20:41:07.983759-07:00","updated_at":"2025-12-20T11:23:03.501652-07:00","closed_at":"2025-12-20T11:23:03.501652-07:00","close_reason":"Updated examples/basic.cr with fuzzy matching examples and verified README.md is accurate"}
{"id":"nucleoc-bsy","title":"Implement robust error handling and recovery for concurrent operations","description":"Implement robust error handling and recovery mechanisms for concurrent operations in CML-based components.\n\n## Why:\nConcurrent systems need proper error handling to prevent cascading failures and ensure system stability. Errors in one fiber shouldn't crash the entire system.\n\n## Requirements:\n1. Add error propagation from worker fibers to main context\n2. Implement supervisor patterns for fault tolerance\n3. Add retry logic with exponential backoff for transient failures\n4. Implement circuit breaker pattern for error rate limiting\n5. Ensure resource cleanup on error (no fiber or channel leaks)\n\n## Implementation Steps:\n1. Study error handling patterns in lib/cml/how_to.md\n2. Implement error channel pattern for propagating exceptions\n3. Create Supervisor class for monitoring and restarting fibers\n4. Add retry logic with configurable policies\n5. Implement circuit breaker for rate limiting failing operations\n6. Integrate error handling into CMLWorkerPool and other components\n7. Add comprehensive error scenario tests\n\n## Files to modify:\n- Create: src/nucleoc/error_handling.cr with error handling patterns\n- Create: src/nucleoc/supervisor.cr for fault tolerance\n- Update: src/nucleoc/worker_pool_cml.cr with error handling\n- Update: src/nucleoc/api.cr to expose error handling options\n- Create: spec/error_handling_spec.cr for tests\n\n## Success Criteria:\n- Errors propagate correctly to calling code\n- Supervisor can restart failed fibers\n- Retry logic handles transient failures\n- Circuit breaker prevents cascading failures\n- No resource leaks on errors\n- Tests cover various error scenarios","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T14:20:38.018806-07:00","updated_at":"2025-12-19T14:20:38.018806-07:00"}
{"id":"nucleoc-dlv","title":"Update worker_pool_cml.cr to use ParSort for match sorting","description":"Update CML worker pool to use ParSort for sorting match results instead of sequential sorting.\n\n## Summary\nThe worker_pool_cml.cr currently uses sequential sorting for match results. Should be updated to use ParSort parallel quicksort for better performance with large result sets.\n\n## Files to Modify\n- src/nucleoc/worker_pool_cml.cr: Replace sequential sort with ParSort.par_quicksort\n- Ensure proper cancellation integration\n\n## Implementation Steps\n1. Import ParSort module in worker_pool_cml.cr\n2. Replace Array#sort with ParSort.par_quicksort\n3. Pass cancellation flag from worker pool to sorting\n4. Test with large match result sets\n\n## Success Criteria\n- Worker pool uses parallel sorting for match results\n- Cancellation propagates to sorting\n- No regression in functionality\n- Performance improvement for large result sets","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-19T17:57:35.443855-07:00","updated_at":"2025-12-19T17:57:47.878259-07:00","dependencies":[{"issue_id":"nucleoc-dlv","depends_on_id":"nucleoc-xgz","type":"blocks","created_at":"2025-12-19T17:59:26.381888-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-efu","title":"Implement MultiPattern support with snapshot system using CML.spawn","description":"Implement MultiPattern support with snapshot system for incremental updates using CML.spawn.\n\n## Why:\nRust nucleo supports MultiPattern for matching multiple patterns simultaneously with snapshot-based incremental updates. This is essential for interactive fuzzy matching in editors.\n\n## Requirements:\n1. Create MultiPattern class in src/nucleoc/multi_pattern.cr\n2. Use CML.spawn for parallel pattern matching\n3. Implement snapshot system for incremental updates\n4. Support pattern status tracking (pending, matching, completed)\n5. Add cancellation support for in-flight patterns\n\n## Implementation Steps:\n1. Design MultiPattern with pattern queue and result aggregation\n2. Use CML.spawn for concurrent pattern matching\n3. Implement snapshot system using BoxcarVector for immutable views\n4. Add status tracking with CML events for pattern lifecycle\n5. Support incremental updates (add/remove patterns without full recomputation)\n\n## Files to modify:\n- Create: src/nucleoc/multi_pattern.cr\n- Update: src/nucleoc/api.cr for MultiPattern API\n- Create: spec/multi_pattern_spec.cr for testing\n- Update: src/nucleoc/worker_pool_cml.cr to support MultiPattern\n\n## Success Criteria:\n- Multiple patterns matched concurrently using CML.spawn\n- Snapshot system provides consistent views for incremental updates\n- Pattern status tracked and cancellable\n- Performance scales with pattern count\n- All tests pass with concurrent pattern matching","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T03:34:19.683821-07:00","updated_at":"2025-12-19T03:35:24.515201-07:00"}
{"id":"nucleoc-fep","title":"Implement advanced CML patterns (choose, wrap, with_nack, guard) for composable concurrency","description":"Implement advanced CML patterns from lib/cml/how_to.md for building more sophisticated concurrent systems.\n\n## Why:\nThe CML library provides powerful patterns (choose, wrap, with_nack, guard) that enable composable concurrency. These are essential for building complex concurrent systems like work stealing, cancellation, and event composition.\n\n## Requirements:\n1. Implement missing CML patterns: choose, wrap, with_nack, guard\n2. Add examples showing how to compose these patterns\n3. Integrate patterns into worker pool and other components\n4. Document pattern usage with examples\n\n## Implementation Steps:\n1. Study lib/cml/how_to.md examples for each pattern\n2. Implement choose combinator for selecting between multiple events\n3. Implement wrap for transforming event results\n4. Implement with_nack for negative acknowledgment (cancellation)\n5. Implement guard for conditional event execution\n6. Create example patterns: worker pool with cancellation, timeout composition, etc.\n7. Update CML documentation with pattern examples\n\n## Files to modify:\n- lib/cml/ patterns implementation (if missing)\n- src/nucleoc/worker_pool_cml.cr: Use advanced patterns\n- examples/advanced_cml_patterns.cr: Add examples\n- README.md: Document pattern usage\n\n## Success Criteria:\n- All advanced CML patterns implemented and tested\n- Patterns composable for complex concurrent logic\n- Worker pool uses patterns for cancellation and timeouts\n- Examples demonstrate real-world usage\n- Documentation helps developers understand pattern composition","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T14:19:25.458327-07:00","updated_at":"2025-12-19T14:19:25.458327-07:00"}
{"id":"nucleoc-g0l","title":"Create performance benchmarks comparing CML.spawn parallelism to Rust rayon","description":"Create performance benchmarks comparing CML.spawn parallelism to Rust rayon implementation.\n\n## Why:\nNeed to understand performance characteristics of Crystal CML-based parallelism vs Rust rayon to guide optimization efforts.\n\n## Requirements:\n1. Create benchmark suite in bench/ directory\n2. Compare single-threaded vs CML.spawn parallel performance\n3. Measure scaling with different core counts\n4. Compare to Rust nucleo benchmarks\n5. Identify bottlenecks and optimization opportunities\n\n## Implementation Steps:\n1. Create bench/src/main.cr with benchmark harness\n2. Implement benchmarks for:\n   - BoxcarVector append performance\n   - Parallel quicksort scaling\n   - Worker pool throughput\n   - MultiPattern concurrent matching\n3. Use Crystal's Benchmark module for measurements\n4. Compare results to Rust nucleo benchmarks\n5. Generate performance reports and charts\n\n## Files to modify:\n- Create: bench/src/main.cr\n- Create: bench/benchmarks/ directory with specific benchmarks\n- Update: README.md with performance results\n- Create: PERFORMANCE.md with detailed analysis\n\n## Success Criteria:\n- Comprehensive benchmark suite covering all parallel components\n- Clear performance comparison between CML.spawn and Rust rayon\n- Identification of performance bottlenecks\n- Documentation of scaling characteristics\n- Guidance for future optimization efforts","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-19T03:34:31.199567-07:00","updated_at":"2025-12-19T03:35:50.464317-07:00"}
{"id":"nucleoc-hn4","title":"Add parallel search worker pool using CML","description":"Implement parallel fuzzy search using CML worker pool\\n\\n## Summary\\nAdd a CML-based worker pool to process match requests concurrently, improving throughput on batch queries.\\n\\n## Requirements\\n1. Introduce worker pool agent (configurable size) that owns matcher instances.\\n2. Add API to submit match tasks (haystack/pattern/config) and gather results in order.\\n3. Use CML choice/merge for work distribution and result collection.\\n4. Provide configuration to enable/disable parallel path (default: enabled with sensible worker count).\\n5. Add specs covering concurrent processing and result correctness.\\n\\n## Files\\n- src/nucleoc/worker_pool.cr (new)\\n- src/nucleoc/api.cr (expose parallel API)\\n- src/nucleoc/matcher.cr (integration)\\n- spec/worker_pool_spec.cr (new)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-19T02:12:13.317607-07:00","updated_at":"2025-12-19T02:15:04.966304-07:00","closed_at":"2025-12-19T02:15:04.966304-07:00","close_reason":"Completed"}
{"id":"nucleoc-i1d","title":"Case-sensitive fuzzy matching test failures","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T14:34:32.701968-07:00","updated_at":"2025-12-19T00:25:23.89115-07:00","closed_at":"2025-12-19T00:25:23.891152-07:00"}
{"id":"nucleoc-i2i","title":"Implement missing core components: boxcar, par_sort, worker","description":"Implement missing core components from Rust nucleo library: boxcar data structure, parallel sorting (par_sort), and worker thread management. These are needed for complete feature parity with Rust implementation. Boxcar provides efficient data storage, par_sort enables parallel sorting of results, worker manages thread pool for concurrent matching. Reference Rust files: boxcar.rs, par_sort.rs, worker.rs in nucleo_rust/src/. Success criteria: All core components implemented and integrated, tests pass, performance matches Rust.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-18T11:59:20.442542-07:00","updated_at":"2025-12-19T01:40:00.157397-07:00","closed_at":"2025-12-19T01:40:00.157397-07:00","close_reason":"Completed","dependencies":[{"issue_id":"nucleoc-i2i","depends_on_id":"nucleoc-6um","type":"discovered-from","created_at":"2025-12-18T11:59:20.443173-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-k50","title":"Add multicast channel support for broadcasting updates to multiple subscribers","description":"Implement multicast channels for broadcasting updates to multiple subscribers, similar to Rust's broadcast channels.\n\n## Why:\nInteractive applications often have multiple UI components that need to receive the same matching results. Multicast channels allow efficient broadcasting of updates without duplicating work.\n\n## Requirements:\n1. Implement multicast channel using CML primitives\n2. Support multiple subscribers (fan-out)\n3. Handle subscriber lifecycle (subscribe/unsubscribe)\n4. Implement backpressure strategies (dropping vs blocking)\n5. Add examples for UI update patterns\n\n## Implementation Steps:\n1. Design MulticastChannel class using CML::Channel as base\n2. Implement subscription mechanism with unique subscriber channels\n3. Use CML.spawn for broadcast fiber\n4. Handle subscriber disconnection (clean up resources)\n5. Implement backpressure: drop-oldest, drop-newest, block\n6. Add tests for concurrent subscribe/unsubscribe scenarios\n7. Integrate with CMLWorkerPool for result broadcasting\n\n## Files to modify:\n- Create: src/nucleoc/multicast_channel.cr\n- Update: src/nucleoc/worker_pool_cml.cr to support multicast\n- Create: spec/multicast_channel_spec.cr\n- examples/multicast_updates.cr: UI update example\n\n## Success Criteria:\n- Multiple subscribers receive same updates\n- Efficient broadcasting without message duplication\n- Proper resource cleanup on unsubscribe\n- Backpressure strategies configurable\n- Integration with worker pool for result broadcasting","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T14:19:39.20538-07:00","updated_at":"2025-12-19T14:19:39.20538-07:00","dependencies":[{"issue_id":"nucleoc-k50","depends_on_id":"nucleoc-fep","type":"blocks","created_at":"2025-12-19T14:21:37.184863-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-kq0","title":"Complete CML-based concurrency system for nucleoc","description":"Epic covering all concurrency improvements to match Rust nucleo's performance using CML patterns.\n\n## Overview:\nThis epic groups all issues related to building a complete, high-performance concurrency system for nucleoc using CML (Concurrent ML) patterns. The goal is to match Rust nucleo's parallel performance while leveraging Crystal's fiber-based concurrency model.\n\n## Included Components:\n1. **Lock-free data structures** (BoxcarVector) for parallel appends\n2. **Advanced CML patterns** (choose, wrap, with_nack, guard) for composable concurrency\n3. **Worker pool enhancements** (work stealing, timeout handling, incremental updates)\n4. **Parallel algorithms** (parallel matcher, parallel quicksort)\n5. **Broadcast mechanisms** (multicast channels for UI updates)\n6. **Fault tolerance** (error handling, supervisor patterns)\n7. **Testing** (comprehensive concurrency tests)\n8. **Benchmarks** (performance comparison with Rust)\n\n## Success Criteria:\n- All components implemented and integrated\n- Performance matches or approaches Rust nucleo for typical workloads\n- System handles concurrent access correctly (no race conditions)\n- Comprehensive test coverage for concurrency scenarios\n- Documentation and examples for using the concurrent API\n\n## Dependencies:\n- Requires CML library to be installed and working\n- Depends on correct fuzzy matching algorithms (separate epic)\n\n## Notes:\nThis epic represents the concurrency architecture work identified during analysis of Rust nucleo implementation and CML patterns documentation.","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-19T14:22:28.936207-07:00","updated_at":"2025-12-19T14:22:28.936207-07:00"}
{"id":"nucleoc-kr7","title":"Enhance CMLWorkerPool with work stealing using CML.spawn","description":"Enhance CMLWorkerPool with work stealing algorithm using CML.spawn for dynamic load balancing.\n\n## Why:\nCurrent round-robin work distribution can lead to load imbalance. Work stealing allows idle workers to steal tasks from busy workers, improving parallel efficiency.\n\n## Requirements:\n1. Modify CMLWorkerPool to support work stealing\n2. Use CML.spawn for worker fibers with task queues\n3. Implement CML channels for work stealing requests\n4. Add dynamic load balancing based on queue sizes\n5. Maintain lock-free design using CML events\n\n## Implementation Steps:\n1. Add per-worker task queues using BoxcarVector\n2. Implement work stealing protocol with CML channels\n3. Use CML.choice to listen for new tasks or steal requests\n4. Add load monitoring to trigger work stealing\n5. Implement backoff strategies to avoid contention\n\n## Files to modify:\n- Update: src/nucleoc/worker_pool_cml.cr\n- Update: src/nucleoc/api.cr for new work stealing API\n- Update: spec/cml_worker_pool_spec.cr for work stealing tests\n\n## Success Criteria:\n- Workers steal tasks when idle\n- Load balanced across all workers\n- No deadlocks in work stealing protocol\n- Performance improves with imbalanced workloads\n- All existing tests continue to pass","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T03:34:14.932166-07:00","updated_at":"2025-12-19T03:35:11.062632-07:00","dependencies":[{"issue_id":"nucleoc-kr7","depends_on_id":"nucleoc-fep","type":"blocks","created_at":"2025-12-19T14:21:32.072136-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-nst","title":"Clean up hardcoded debug patterns in optimal matcher","description":"Remove hardcoded debug patterns and conditional debug logic from optimal matcher implementation.\n\nCurrent State:\n- Hardcoded debug patterns for specific test cases\n- Conditional debug logic scattered through score_row_first and score_row methods\n- Debug output mixed with core algorithm logic\n\nRequirements:\n1. Remove hardcoded debug patterns\n2. Consolidate debug logic into separate methods\n3. Ensure algorithm logic is clean without debug statements\n4. Update debug gating to use proper logging levels\n\nFiles to modify:\n- src/nucleoc/matcher.cr: Remove hardcoded debug patterns\n- src/nucleoc/matcher.cr: Consolidate debug logic\n\nSuccess Criteria:\n- No hardcoded test case checks in algorithm\n- Debug output properly gated and organized\n- Core algorithm logic clean and readable\n- All tests still pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T20:40:01.747422-07:00","updated_at":"2025-12-19T02:03:58.939109-07:00","closed_at":"2025-12-19T02:03:58.939109-07:00","close_reason":"Completed"}
{"id":"nucleoc-pek","title":"Add incremental update support to CMLWorkerPool using CML.spawn","description":"Add incremental update support to CMLWorkerPool using CML.spawn for efficient partial recomputation.\n\n## Why:\nInteractive applications need to update fuzzy matches incrementally as data changes, not recompute everything from scratch.\n\n## Requirements:\n1. Add incremental update API to CMLWorkerPool\n2. Use CML.spawn for parallel incremental processing\n3. Implement diff-based updates using snapshot system\n4. Support partial recomputation of changed items only\n5. Maintain consistency during concurrent updates\n\n## Implementation Steps:\n1. Extend CMLWorkerPool with update method for incremental changes\n2. Use BoxcarVector snapshots to identify changed items\n3. Spawn CML fibers for parallel processing of changed items\n4. Merge incremental results with existing results\n5. Ensure atomic updates with CML events for consistency\n\n## Files to modify:\n- Update: src/nucleoc/worker_pool_cml.cr\n- Update: src/nucleoc/api.cr for incremental update API\n- Update: spec/cml_worker_pool_spec.cr for incremental update tests\n- Create: examples/incremental_updates.cr\n\n## Success Criteria:\n- Partial recomputation of changed items only\n- Parallel processing of updates using CML.spawn\n- Consistent results during concurrent updates\n- Performance improves for small changes vs full recomputation\n- All tests pass with incremental update scenarios","status":"open","priority":2,"issue_type":"feature","created_at":"2025-12-19T03:34:25.696021-07:00","updated_at":"2025-12-19T03:35:37.993621-07:00","dependencies":[{"issue_id":"nucleoc-pek","depends_on_id":"nucleoc-efu","type":"blocks","created_at":"2025-12-19T14:21:47.142702-07:00","created_by":"daemon","metadata":"{}"},{"issue_id":"nucleoc-pek","depends_on_id":"nucleoc-ujs","type":"blocks","created_at":"2025-12-19T14:21:51.825078-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-ti3","title":"Case-insensitive equality test failures","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T14:34:42.901834-07:00","updated_at":"2025-12-19T00:25:36.257345-07:00","closed_at":"2025-12-19T00:25:36.257347-07:00"}
{"id":"nucleoc-uf4","title":"Fix remaining optimal fuzzy matching reconstruction failures","description":"Three tests fail due to optimal algorithm reconstruction issues.\n\nDebug findings:\n1) 'obr' in 'fooBarbaz1' passes after fixes (indices correct).\n2) 'changelog' in '/usr/share/doc/at/ChangeLog' now passes after fixing row splitting logic.\n3) '12356' in 'ab0123 456' fails: indices [0,0,0,8,9] vs [3,4,5,8,9]. Reconstruction picks wrong path due to matrix cell data corruption (issue nucleoc-8xv). Also best score selection may be wrong.\n4) 'fbb' in 'foo/bar/baz' fails: indices [0,6,8] vs [0,4,8]. Same matrix corruption issue.\n\nRoot causes:\n- MatrixCell data corruption (extra bits set)\n- Reconstruction algorithm may have column adjustment bugs\n- Prefilter for case-insensitive matches picks first occurrence, not necessarily best (but row_offs correct)\n\nFiles to modify:\nsrc/nucleoc/matcher.cr: MatrixCell.set, score_row_first, score_row, reconstruct_optimal_path.\n\nDependencies:\nnucleoc-8xv (matrix cell corruption) must be fixed first.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-18T16:06:35.840875-07:00","updated_at":"2025-12-18T20:41:18.456163-07:00","closed_at":"2025-12-18T20:41:18.456165-07:00"}
{"id":"nucleoc-ujs","title":"Implement boxcar-like lock-free vector using CML.spawn for parallel appends","description":"Implement a boxcar-like lock-free vector for parallel appends using CML.spawn fibers.\n\n## Why:\nRust nucleo uses boxcar::Vec for lock-free append-only storage in parallel processing. We need similar functionality in Crystal to support parallel fuzzy matching without locks.\n\n## Requirements:\n1. Create BoxcarVector class in src/nucleoc/boxcar.cr\n2. Use CML.spawn for parallel appends from multiple fibers\n3. Lock-free design using atomic operations\n4. Append-only semantics (no removal)\n5. Thread-safe iteration\n6. Support for snapshotting (immutable views)\n\n## Implementation Steps:\n1. Design atomic append using Crystal's Atomic type\n2. Use CML.spawn for concurrent append operations\n3. Implement growable buffer with capacity doubling\n4. Add snapshot method that returns immutable view\n5. Write tests for concurrent append scenarios\n\n## Files to modify:\n- Create: src/nucleoc/boxcar.cr\n- Update: src/nucleoc/api.cr to use BoxcarVector\n- Create: spec/boxcar_spec.cr for testing\n\n## Success Criteria:\n- Multiple fibers can append concurrently without locks\n- Atomic operations ensure data consistency\n- Snapshot provides immutable view for parallel processing\n- All tests pass with concurrent access patterns","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-19T03:34:06.054984-07:00","updated_at":"2025-12-19T15:09:13.382012-07:00","closed_at":"2025-12-19T15:09:13.382012-07:00","close_reason":"Completed implementation of BoxcarVector with CML.spawn parallel appends, lock-free design, atomic operations, snapshotting, and comprehensive tests."}
{"id":"nucleoc-wu9","title":"Implement MultiPattern for incremental pattern updates","description":"## Summary\\nImplement MultiPattern class for handling incremental pattern updates with status tracking.\\n\\n## Missing from Crystal:\\n- MultiPattern struct for managing multiple pattern columns\\n- Status enum (Unchanged, Update, Rescore)\\n- Incremental reparse with append optimization\\n- Status tracking for pattern changes\\n\\n## Rust Reference:\\n- File: \\n- Test:  (append test)\\n\\n## Requirements:\\n1. Implement MultiPattern class with columns vector\\n2. Add Status enum (Unchanged, Update, Rescore)\\n3. Implement reparse method with append optimization\\n4. Add status tracking and query methods\\n5. Create tests matching Rust append() test\\n\\n## Success Criteria:\\n- MultiPattern can handle incremental pattern updates\\n- Status correctly tracks pattern changes\\n- Tests pass matching Rust behavior","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-18T11:58:32.185024-07:00","updated_at":"2025-12-19T01:39:47.049209-07:00","closed_at":"2025-12-19T01:39:47.049209-07:00","close_reason":"Completed","dependencies":[{"issue_id":"nucleoc-wu9","depends_on_id":"nucleoc-6um.4","type":"discovered-from","created_at":"2025-12-18T11:58:32.186673-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-xgz","title":"Integrate ParSort with BoxcarVector for sorting MatchResult","description":"Integrate ParSort parallel sorting with BoxcarVector to enable efficient sorting of MatchResult structs for fuzzy matching results.\n\n## Summary\nBoxcarVector provides lock-free, append-only storage for match results. Need to integrate ParSort to sort MatchResult arrays stored in BoxcarVector for final result presentation.\n\n## Files to Modify\n- src/nucleoc/par_sort.cr: Add specialized sorting for BoxcarVector snapshots\n- src/nucleoc/boxcar.cr: Add sort_snapshot method using ParSort\n- src/nucleoc/worker_pool_cml.cr: Use sorted results from BoxcarVector\n\n## Implementation Steps\n1. Add BoxcarVector#sort_snapshot method\n2. Optimize for MatchResult comparison (score descending, then indices)\n3. Integrate with worker pool for sorted match results\n\n## Success Criteria\n- MatchResult arrays can be sorted efficiently using ParSort\n- Worker pool returns sorted results\n- No performance regression","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-19T17:56:43.11894-07:00","updated_at":"2025-12-20T11:53:25.283006-07:00","closed_at":"2025-12-20T11:53:25.283006-07:00","close_reason":"Completed","dependencies":[{"issue_id":"nucleoc-xgz","depends_on_id":"nucleoc-842","type":"blocks","created_at":"2025-12-19T17:59:18.634255-07:00","created_by":"daemon","metadata":"{}"}]}
{"id":"nucleoc-ypr","title":"Replace debug puts with Crystal Log system in matcher.cr","description":"Replace scattered debug puts statements in matcher.cr with Crystal's standard Log system for better integration and control.\n\n## Current State:\n- Debug output uses scattered  statements gated by  env var\n- Hardcoded debug patterns for specific test cases ('ab0123 456'/'12356')\n- No standard logging levels or configuration\n\n## Requirements:\n1. Replace all debug  with  calls\n2. Use  to respect standard  env var\n3. Add appropriate log levels:\n   - DEBUG: Matrix details, reconstruction steps\n   - INFO: General matching operations, scores\n   - WARN: Edge cases, performance warnings\n4. Remove hardcoded debug patterns\n5. Update spec_helper.cr to configure logging for tests\n6. Document logging usage in README.md\n\n## Files to modify:\n- src/nucleoc/matcher.cr: Replace debug puts with Log calls\n- spec/spec_helper.cr: Add logging configuration\n- README.md: Document logging usage\n\n## Success Criteria:\n- All debug output uses Crystal Log system\n- Log levels controllable via LOG_LEVEL env var\n- Tests pass with logging enabled/disabled\n- No hardcoded debug patterns","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-18T20:39:15.960425-07:00","updated_at":"2025-12-19T02:02:33.319205-07:00","closed_at":"2025-12-19T02:02:33.319205-07:00","close_reason":"Completed"}
